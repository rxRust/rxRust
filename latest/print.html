<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The rxRust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-2afe6447.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-959fc176.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The rxRust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rxRust/rxRust" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <strong>rxRust</strong> v1.0!</p>
<p>rxRust is a zero-cost, ergonomic, and functional reactive programming (FRP) library for Rust. It brings the widely adopted <a href="http://reactivex.io">ReactiveX</a> pattern to the Rust ecosystem, designed specifically for scenarios where standard Async Streams fall short. It serves as the core reactive engine for high-performance GUI frameworks like <a href="https://github.com/RibirX/Ribir">Ribir</a>.</p>
<h2 id="push-vs-pull-why-observable"><a class="header" href="#push-vs-pull-why-observable">Push vs. Pull: Why Observable?</a></h2>
<p>In Rust, we are familiar with <code>Iterator</code> and <code>Future</code>/<code>Stream</code>. These are <strong>Pull-based</strong> systems: the consumer decides when to ask for the next value (“Give me the next item”). This works perfectly for reading files or database cursors.</p>
<p>However, real-world applications—especially GUIs, Web Apps, and IoT—are <strong>Push-based</strong>.</p>
<ul>
<li>A user clicks a button.</li>
<li>A WebSocket message arrives.</li>
<li>A timer fires.</li>
</ul>
<p>You cannot “ask” a mouse for the next click; the mouse “pushes” the click to you.</p>
<p>rxRust’s <strong>Observable</strong> is the standard for <strong>Push-based</strong> composition. It allows you to orchestrate complex event streams declaratively, rather than managing messy callbacks or state machines.</p>
<blockquote>
<p>“ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.” — <a href="http://reactivex.io">ReactiveX.io</a></p>
</blockquote>
<h2 id="the-aha-moment"><a class="header" href="#the-aha-moment">The “Aha!” Moment</a></h2>
<p>Why choose rxRust over raw <code>tokio</code> channels or streams?</p>
<p>Consider a “Type-ahead Search” (Auto-complete):</p>
<ol>
<li>Wait for 300ms silence (<strong>Debounce</strong>).</li>
<li>Ignore if the text hasn’t changed (<strong>Distinct</strong>).</li>
<li>Cancel the previous request if a new one starts (<strong>Switch</strong>).</li>
</ol>
<p>With rxRust, complex timing and state logic become a linear pipeline:</p>
<pre><code class="language-rust ignore">use rxrust::prelude::*;

input_events
    .debounce(Duration::from_millis(300))
    .distinct_until_changed()
    .switch_map(|text| api_search(text)) // Automatically cancels old requests
    .subscribe(|results| render(results));</code></pre>
<h2 id="why-rxrust-specifically"><a class="header" href="#why-rxrust-specifically">Why rxRust Specifically?</a></h2>
<p>While there are other reactive libraries, rxRust is built with a unique philosophy:</p>
<h3 id="1-wasm--gui-first-local-context"><a class="header" href="#1-wasm--gui-first-local-context">1. WASM &amp; GUI First (Local Context)</a></h3>
<p>Most Rust async libraries force <code>Send + Sync</code> constraints to support multi-threaded runtimes. This incurs unnecessary locking overhead (<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>) for single-threaded environments like <strong>WebAssembly (WASM)</strong> or <strong>UI Main Threads</strong>.</p>
<p>rxRust provides a <code>Local</code> context based on <code>Rc&lt;RefCell&gt;</code>, offering <strong>zero-locking overhead</strong> for these high-performance client-side scenarios.</p>
<h3 id="2-unified-concurrency-shared-context"><a class="header" href="#2-unified-concurrency-shared-context">2. Unified Concurrency (Shared Context)</a></h3>
<p>Need to scale to a multi-threaded server? Just switch to the <code>Shared</code> context. The API remains the same, but the implementation automatically switches to thread-safe primitives (<code>Arc&lt;Mutex&gt;</code>) and work-stealing schedulers.</p>
<h3 id="3-seamless-interop"><a class="header" href="#3-seamless-interop">3. Seamless Interop</a></h3>
<p>We believe Push and Pull should coexist. rxRust makes it trivial to bridge the worlds:</p>
<ul>
<li><strong><code>from_stream</code></strong>: Turn a Tokio Stream into an Observable to apply complex time-based operators.</li>
<li><strong><code>into_stream</code></strong>: Turn an Observable back into a Stream to consume it in a standard <code>async</code> loop.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add rxRust to your <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
rxrust = "1.0.0-beta.11"
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Here is a minimal example using the <code>Local</code> context, which is optimized for single-threaded environments (like WASM or UI main threads).</p>
<pre class="playground"><code class="language-rust">use rxrust::prelude::*;

fn main() {
    // 1. Create an Observable that emits a single value (42)
    Local::of(42)
        // 2. Transform the value
        .map(|v| v * 2)
        // 3. Subscribe to consume the value
        .subscribe(|v| println!("Value: {}", v));
}</code></pre>
<h2 id="the-mental-model"><a class="header" href="#the-mental-model">The Mental Model</a></h2>
<p>RxRust programming revolves around three key components:</p>
<ol>
<li><strong>Observable (The Source)</strong>: Represents a stream of events over time. It’s lazy—nothing happens until you subscribe.</li>
<li><strong>Operators (The Pipeline)</strong>: Pure functions that transform, filter, or combine streams (e.g., <code>map</code>, <code>filter</code>, <code>merge</code>).</li>
<li><strong>Subscription (The Link)</strong>: Connects an Observer to an Observable, starting the execution.</li>
</ol>
<h3 id="managing-subscriptions"><a class="header" href="#managing-subscriptions">Managing Subscriptions</a></h3>
<p>Unlike standard Iterators, Observables push data. You often need to manage the lifecycle of a subscription (e.g., to cancel a network request or stop a timer).</p>
<pre class="playground"><code class="language-rust">use rxrust::prelude::*;

fn main() {
    // A 'Subject' allows us to imperatively push values into a stream
    let mut subject = Local::subject();

    // Create a subscription
    let subscription = subject.clone()
        .map(|x: i32| x * 2)
        .subscribe(|v| println!("Got: {}", v));

    // Push values
    subject.next(1); // Output: Got: 2
    subject.next(2); // Output: Got: 4

    // Cancel the subscription
    subscription.unsubscribe();

    // This value will be ignored
    subject.next(3); 
}</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the basic flow, dive into the core concepts:</p>
<ul>
<li><strong><a href="#context">Context &amp; Threading</a></strong>: Learn when to use <code>Local</code> vs <code>Shared</code>.</li>
<li><strong><a href="#operators">Operators</a></strong>: Explore the rich vocabulary of stream transformations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>While rxRust follows the <a href="http://reactivex.io">ReactiveX standard</a>, the implementation is adapted to Rust’s unique ownership and type system.</p>
<h2 id="the-triad-observable-observer-subscription"><a class="header" href="#the-triad-observable-observer-subscription">The Triad: Observable, Observer, Subscription</a></h2>
<h3 id="1-observable-the-source"><a class="header" href="#1-observable-the-source">1. Observable (The Source)</a></h3>
<p>In rxRust, an <code>Observable</code> is a lazy computation. Nothing happens until you subscribe.</p>
<ul>
<li><strong>Rust Specific</strong>: It owns its data. When you call an operator (e.g., <code>map</code>), the original observable is <em>consumed</em> (moved) into the new one.</li>
</ul>
<h3 id="2-observer-the-consumer"><a class="header" href="#2-observer-the-consumer">2. Observer (The Consumer)</a></h3>
<p>The logic that reacts to events (<code>next</code>, <code>error</code>, <code>complete</code>).</p>
<ul>
<li><strong>Rust Specific</strong>: You rarely implement the <code>Observer</code> trait manually. Instead, you pass a closure to <code>.subscribe(|v| ... )</code>.</li>
</ul>
<h3 id="3-subscription-the-link"><a class="header" href="#3-subscription-the-link">3. Subscription (The Link)</a></h3>
<p>The connection between Source and Consumer.</p>
<p>Unlike some other Rx implementations, an <code>Subscription</code> object itself <strong>does not</strong> automatically unsubscribe when it’s dropped. This gives you explicit control over the subscription’s lifecycle.</p>
<p>To enable <strong>RAII</strong> (Resource Acquisition Is Initialization) behavior—where the stream is automatically cancelled when a guard goes out of scope—you must explicitly call <code>unsubscribe_when_dropped()</code>:</p>
<ul>
<li><strong>Explicit Control</strong>: Call <code>subscription.unsubscribe()</code> manually.</li>
<li><strong>RAII (Automatic Unsubscribe)</strong>: Use <code>subscription.unsubscribe_when_dropped()</code> to get a guard that unsubscribes on drop. You must hold this guard.</li>
</ul>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

// Example of explicit unsubscribe
let subscription = Local::interval(Duration::from_secs(1))
    .subscribe(|_| println!("Tick (explicit)"));
// Stream runs...
// To stop: subscription.unsubscribe();

// Example of RAII for automatic unsubscribe
{
    let sub = Local::interval(Duration::from_secs(1))
        .subscribe(|_| println!("Tick (RAII)"));
    let _guard = sub.unsubscribe_when_dropped();
    // Stream runs as long as _guard is in scope...
    // When _guard drops here, the stream is cancelled.
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="key-architectural-concepts"><a class="header" href="#key-architectural-concepts">Key Architectural Concepts</a></h2>
<p>To adapt Reactive Programming to Rust’s compile-time guarantees, rxRust introduces specific architectural patterns:</p>
<ul>
<li><strong><a href="#context">Context</a></strong>: Solves the <em>Thread-Safety vs Performance</em> dilemma by splitting the world into <code>Local</code> and <code>Shared</code>.</li>
<li><strong><a href="#scheduler">Scheduler</a></strong>: Tightly integrated with Context to manage <em>Time</em> without boilerplate.</li>
<li><strong><a href="#type-erasure">Type Erasure</a></strong>: Techniques (<code>box_it</code>, <code>impl Observable</code>) to manage Rust’s complex iterator types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>In rxRust v1.0, the <strong>Context</strong> is the foundation that defines the <strong>execution environment</strong> of a reactive stream.</p>
<p>It answers three key questions for the compiler and the runtime:</p>
<ol>
<li><strong>Memory Strategy</strong>: How is state shared? (<code>Rc</code> vs <code>Arc</code>)</li>
<li><strong>Scheduling</strong>: How is time managed? (Main Loop vs Thread Pool)</li>
<li><strong>Thread Safety</strong>: Can this stream cross thread boundaries? (<code>!Send</code> vs <code>Send + Sync</code>)</li>
</ol>
<h2 id="why-context"><a class="header" href="#why-context">Why Context?</a></h2>
<p>In Rust, generic libraries often face a dilemma:</p>
<ul>
<li>Make everything <code>Send + Sync</code> (Thread-safe) -&gt; Incurs overhead (<code>Arc&lt;Mutex&gt;</code>) which is wasteful for single-threaded environments like WASM or GUIs.</li>
<li>Make everything <code>!Send</code> (Local) -&gt; Prevents usage in multi-threaded server environments.</li>
</ul>
<p>rxRust solves this by introducing a generic <code>Context</code> trait. Instead of forcing a single implementation, rxRust provides <strong>Unified Logic</strong> that adapts to the <strong>Context</strong> you choose.</p>
<h2 id="standard-contexts"><a class="header" href="#standard-contexts">Standard Contexts</a></h2>
<p>rxRust provides two built-in contexts to cover the most common scenarios.</p>
<h3 id="1-local-context"><a class="header" href="#1-local-context">1. <code>Local</code> Context</a></h3>
<ul>
<li><strong>Environment</strong>: Single-threaded (Main Thread, WASM, Embedded).</li>
<li><strong>Strategy</strong>: Uses <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> for sharing state.</li>
<li><strong>Scheduler</strong>: <code>LocalScheduler</code> (runs on the current thread’s loop).</li>
<li><strong>Constraint</strong>: <code>!Send</code>. The compiler prevents these streams from moving to other threads.</li>
</ul>
<h3 id="2-shared-context"><a class="header" href="#2-shared-context">2. <code>Shared</code> Context</a></h3>
<ul>
<li><strong>Environment</strong>: Multi-threaded (Background workers, Servers).</li>
<li><strong>Strategy</strong>: Uses <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for sharing state.</li>
<li><strong>Scheduler</strong>: <code>SharedScheduler</code> (uses a thread pool).</li>
<li><strong>Constraint</strong>: <code>Send + Sync</code>. Safe to move across threads.</li>
</ul>
<h2 id="important-context--auto-concurrency"><a class="header" href="#important-context--auto-concurrency">Important: Context ≠ Auto-Concurrency</a></h2>
<p>Using <code>Shared</code> context does <strong>not</strong> automatically spawn threads for every operator. It simply <strong>enables</strong> thread safety guarantees so you <em>can</em> use concurrency.</p>
<ul>
<li>By default, <code>Shared::of(1).map(...)</code> executes on the current thread, just with thread-safe primitives.</li>
<li>To actually execute on another thread, you must explicitly use <strong>Scheduler Operators</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;
use std::thread;

// 1. Create in Shared context (Thread-Safe)
let stream = Shared::from_iter(1..=1000)
    .map(|v| v * 2);

// 2. Explicitly schedule subscription on a background thread
stream
    .subscribe_on(SharedScheduler) 
    .subscribe(|v| println!("Received on {:?}: {}", thread::current().id(), v));
<span class="boring">}</span></code></pre>
<h2 id="the-factory-pattern"><a class="header" href="#the-factory-pattern">The “Factory” Pattern</a></h2>
<p>Contexts acts as factories for creating Observables. This ensures that a stream starts with the correct environment settings from the very beginning.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

// Create a stream optimized for the Local environment
Local::of(1); 

// Create a stream ready for Multi-threaded environments
Shared::of(1);
<span class="boring">}</span></code></pre>
<h2 id="custom-contexts-extensibility"><a class="header" href="#custom-contexts-extensibility">Custom Contexts (Extensibility)</a></h2>
<p>The <code>Context</code> is a trait, not a hardcoded enum. This means rxRust is extensible.
Advanced users can implement their own Context to integrate with:</p>
<ul>
<li><strong>Custom Async Runtimes</strong>: Integrate rxRust with your own event loop or asynchronous runtime, bypassing default integrations like <code>tokio</code>.</li>
<li><strong>Game Engines</strong>: Bind the Scheduler to the game’s frame loop.</li>
<li><strong>Embedded Systems</strong>: Bind to a custom hardware timer or interrupt controller.</li>
<li><strong>Frameworks</strong>: Deep integration with frameworks like Tauri or Ribir.</li>
</ul>
<p>See <a href="advanced/custom_context.html">Advanced Topics: Custom Context</a> for implementation details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h1>
<p>In Reactive Programming, a <strong>Scheduler</strong> controls <em>when</em> a task is executed.</p>
<h2 id="the-rxrust-approach-context-bound-scheduling"><a class="header" href="#the-rxrust-approach-context-bound-scheduling">The rxRust Approach: Context-Bound Scheduling</a></h2>
<p>A key difference in rxRust v1.0 is that the <strong>Scheduler is implicitly bound to its Context</strong>.</p>
<ul>
<li><code>Local</code> context -&gt; <code>LocalScheduler</code></li>
<li><code>Shared</code> context -&gt; <code>SharedScheduler</code></li>
</ul>
<p>This means operators like <code>delay</code>, <code>throttle</code>, and <code>debounce</code> automatically use the appropriate scheduling mechanism for your environment without needing explicit arguments.</p>
<h3 id="explicit-scheduler-control-xxx_with-methods"><a class="header" href="#explicit-scheduler-control-xxx_with-methods">Explicit Scheduler Control (<code>xxx_with</code> methods)</a></h3>
<p>For situations where you need to explicitly override the default scheduler, many time-based operators provide a <code>_with</code> suffix method.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

// Uses SharedScheduler explicitly
Shared::of(1)
    .delay_with(Duration::from_secs(1), SharedScheduler) 
    .subscribe(|v| println!("Delayed Shared Value: {}", v));
<span class="boring">}</span></code></pre>
<h2 id="scheduler-types"><a class="header" href="#scheduler-types">Scheduler Types</a></h2>
<h3 id="localscheduler"><a class="header" href="#localscheduler"><code>LocalScheduler</code></a></h3>
<ul>
<li><strong>Role</strong>: Executes tasks on the current thread’s event loop.</li>
<li><strong>Environment</strong>:
<ul>
<li><strong>WASM</strong>: Wraps <code>setTimeout</code> / <code>requestAnimationFrame</code>.</li>
<li><strong>Native</strong>: Integrates with the local task runner (e.g., <code>tokio::task::LocalSet</code>).</li>
</ul>
</li>
<li><strong>Key Benefit</strong>: Does <strong>not</strong> require <code>Send</code>. This allows you to schedule tasks involving <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> or DOM objects, avoiding the overhead of atomics and mutexes.</li>
</ul>
<h3 id="sharedscheduler"><a class="header" href="#sharedscheduler"><code>SharedScheduler</code></a></h3>
<ul>
<li><strong>Role</strong>: Executes tasks in a thread-safe manner, often allowing parallelism.</li>
<li><strong>Environment</strong>:
<ul>
<li><strong>Native</strong>: Dispatches to a global thread pool (e.g., <code>tokio::spawn</code>). Requires <code>Send</code>.</li>
<li><strong>WASM</strong>: Falls back to <code>spawn_local</code> (since WASM threads are limited), but still enforces <code>Send</code> bounds to ensure portability.</li>
</ul>
</li>
<li><strong>Key Benefit</strong>: Enables utilizing multi-core processors for heavy computations.</li>
</ul>
<h2 id="scheduler-as-a-handle-important"><a class="header" href="#scheduler-as-a-handle-important">Scheduler as a Handle (Important!)</a></h2>
<p>In rxRust, a <code>Scheduler</code> struct is essentially a <strong>handle</strong> or a <strong>pointer</strong> to an execution runtime. It is <strong>not</strong> the runtime itself.</p>
<ul>
<li><strong>Instance-Agnostic</strong>: Creating a new instance of <code>LocalScheduler</code> (via <code>LocalScheduler::default()</code>) <strong>does not</strong> create a new thread or event loop. All <code>LocalScheduler</code> instances in the same thread share the same underlying thread-local executor.</li>
<li><strong>Shared Runtime</strong>: Similarly, all <code>SharedScheduler</code> instances dispatch tasks to the same global thread pool (e.g., Tokio’s global runtime).</li>
</ul>
<p>This design allows operators to cheaply create scheduler instances on the fly without performance penalties or resource leaks. When implementing your own scheduler, ensure it follows this pattern: your scheduler struct should be a lightweight handle to a shared, persistent runtime.</p>
<h2 id="unified-task-management-taskhandle"><a class="header" href="#unified-task-management-taskhandle">Unified Task Management (<code>TaskHandle</code>)</a></h2>
<p>In rxRust, the result of scheduling a task is a <code>TaskHandle</code>.</p>
<ul>
<li>It implements <strong><code>Subscription</code></strong> (cancellable).</li>
<li>It implements <strong><code>Future</code></strong> (awaitable).</li>
</ul>
<p>This unification simplifies resource management, allowing you to treat Rx subscriptions and Async futures uniformly.</p>
<h2 id="switching-schedulers-observe_on-and-subscribe_on"><a class="header" href="#switching-schedulers-observe_on-and-subscribe_on">Switching Schedulers (<code>observe_on</code> and <code>subscribe_on</code>)</a></h2>
<p>You can use specific operators to control where an Observable chain executes.</p>
<h3 id="observe_on-where-observation-occurs"><a class="header" href="#observe_on-where-observation-occurs"><code>observe_on</code> (Where Observation Occurs)</a></h3>
<p><code>observe_on</code> changes the scheduler for <strong>all downstream operations</strong> from the point it’s applied. It dictates <em>where the emissions are processed</em>.</p>
<h3 id="subscribe_on-where-subscription-occurs"><a class="header" href="#subscribe_on-where-subscription-occurs"><code>subscribe_on</code> (Where Subscription Occurs)</a></h3>
<p><code>subscribe_on</code> changes the scheduler where the <strong>entire Observable chain’s subscription logic and source execution occurs</strong>. It dictates <em>where the stream is set up and starts producing values</em>.</p>
<p><strong>Key Differences:</strong></p>
<ul>
<li><code>observe_on</code> affects the <strong>consumer side</strong> of the stream after it’s been set up.</li>
<li><code>subscribe_on</code> affects the <strong>producer side</strong> and the initial setup of the stream.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust no_run">use rxrust::prelude::*;
use std::thread;

fn main() {
    println!("Main Thread: {:?}", thread::current().id());

    // This Observable will be subscribed to and execute on SharedScheduler
    let source = Shared::interval(Duration::from_millis(100));

    source
        .map(|v| {
            println!("Source execution on: {:?}", thread::current().id());
            v * 2
        })
        .subscribe_on(SharedScheduler) // The subscription and source will run on SharedScheduler
        .observe_on(LocalScheduler) // All emissions *after* this point will be observed on LocalScheduler
        .subscribe(|v| {
            println!("Observer on: {:?}", thread::current().id());
            println!("Value: {}", v);
        });
}</code></pre>
<h3 id="rules-for-switching"><a class="header" href="#rules-for-switching">Rules for Switching</a></h3>
<p>If your stream is created in a <code>Local</code> context (and thus holds <code>Rc</code> or <code>!Send</code> data), you <strong>cannot</strong> simply <code>observe_on(SharedScheduler)</code> or <code>subscribe_on(SharedScheduler)</code> to move it to a background thread. The Rust compiler will prevent this because <code>Rc</code> and non-<code>Send</code> types cannot safely cross thread boundaries.</p>
<p><strong>Correct Pattern for Offloading Work:</strong></p>
<p>If you need to perform heavy computation on a background thread, you must ensure your data stream starts as <code>Shared</code> (or carries only <code>Send</code> data) from the beginning.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;
use std::thread;

// Correct: Start with Shared context if you plan to use threads
Shared::from_iter(1..=1000)
    .map(|v| v * 2) // Runs on creating thread
    .observe_on(SharedScheduler) // Switch to thread pool for map/further ops
    .map(|v| {
        // Heavy computation here
        println!("Background: {:?}", thread::current().id());
        v
    })
    .subscribe(|_| {});
<span class="boring">}</span></code></pre>
<h2 id="virtual-time-for-testing-testscheduler"><a class="header" href="#virtual-time-for-testing-testscheduler">Virtual Time for Testing (<code>TestScheduler</code>)</a></h2>
<p>rxRust provides a <code>TestScheduler</code> to simulate time. This is essential for testing time-dependent logic (like <code>debounce</code>) instantly and deterministically.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-erasure"><a class="header" href="#type-erasure">Type Erasure</a></h1>
<p>One common challenge when working with RxRust (and Rust iterators/futures in general) is the rapidly growing complexity of types.</p>
<h2 id="the-problem-type-explosion"><a class="header" href="#the-problem-type-explosion">The Problem: Type Explosion</a></h2>
<p>Every operator you apply wraps the previous Observable in a new struct.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

// Type: LocalObservable&lt;Map&lt;Filter&lt;Range, ...&gt;, ...&gt;, ...&gt;
let stream = Local::from_iter(0..10)
    .filter(|v| v % 2 == 0)
    .map(|v| v * 2);
<span class="boring">}</span></code></pre>
<p>While these types are usually inferred by the compiler, they become problematic when you need to:</p>
<ol>
<li>Return an Observable from a function.</li>
<li>Store an Observable in a struct.</li>
<li>Conditionally return different Observable chains.</li>
</ol>
<h2 id="solution-1-impl-observable-zero-cost"><a class="header" href="#solution-1-impl-observable-zero-cost">Solution 1: <code>impl Observable</code> (Zero Cost)</a></h2>
<p>If you are returning an Observable from a function, the preferred way is to use <code>impl Observable</code>. This keeps the concrete type hidden but maintains static dispatch (zero runtime overhead).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;
use std::convert::Infallible;

fn create_stream() -&gt; impl for&lt;'a&gt; Observable&lt;Item&lt;'a&gt; = i32, Err = Infallible&gt; {
    Local::from_iter(0..10)
        .filter(|v| v % 2 == 0)
        .map(|v| v * 2)
}
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Zero runtime cost.</li>
<li>No heap allocation.</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Cannot be stored in a struct field (unless generic).</li>
<li>All code paths must return the exact same concrete type.</li>
</ul>
<h2 id="solution-2-box_it-dynamic-dispatch"><a class="header" href="#solution-2-box_it-dynamic-dispatch">Solution 2: <code>box_it()</code> (Dynamic Dispatch)</a></h2>
<p>When you need to store an Observable or return different types from different branches, you need <strong>Type Erasure</strong>. The <code>.box_it()</code> operator boxes the observable, unifying the type to <code>LocalBoxedObservable</code> (or <code>SharedBoxedObservable</code>).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

fn create_dynamic_stream(condition: bool) -&gt; LocalBoxedObservable&lt;'static, i32, ()&gt; {
    if condition {
        Local::of(1).map_err(|_| ()).box_it()
    } else {
        Local::from_iter(0..10).map(|v| v * 2).map_err(|_| ()).box_it()
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Returns a unified concrete type (one of the 4 boxed variants, e.g., <code>LocalBoxedObservable</code>).</li>
<li>Can be stored in structs easily.</li>
</ul>
<h3 id="cloneable-boxed-observables-box_it_clone--box_it_mut_ref_clone"><a class="header" href="#cloneable-boxed-observables-box_it_clone--box_it_mut_ref_clone">Cloneable boxed observables: <code>box_it_clone()</code> / <code>box_it_mut_ref_clone()</code></a></h3>
<p>The regular <code>box_it()</code> result is not <code>Clone</code>, because a boxed trait object
cannot be cloned unless the underlying observable pipeline is cloneable.</p>
<p>If you need a boxed observable that can be cloned (for example, to keep a
template observable in a struct and create copies for multiple independent
subscriptions), use <code>box_it_clone()</code>.</p>
<pre class="playground"><code class="language-rust">use rxrust::prelude::*;
use std::convert::Infallible;

fn create_cloneable_stream() -&gt; LocalBoxedObservableClone&lt;'static, i32, Infallible&gt; {
    // Works when the underlying pipeline is `Clone`
    Local::of(42).box_it_clone()
}

fn main() {
    let boxed = create_cloneable_stream();
    let boxed2 = boxed.clone();

    boxed.subscribe(|v| {
        assert_eq!(v, 42);
    });

    boxed2.subscribe(|v| {
        assert_eq!(v, 42);
    });
}</code></pre>
<p>For observables that emit mutable references (<code>Item = &amp;'a mut T</code>), use
<code>box_it_mut_ref_clone()</code>.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Function return type</td><td><code>impl Observable</code></td></tr>
<tr><td>Conditional branches</td><td><code>box_it()</code></td></tr>
<tr><td>Struct fields</td><td><code>box_it()</code> or Generic parameters</td></tr>
<tr><td>API boundaries</td><td><code>box_it()</code> (usually easier for consumers)</td></tr>
<tr><td>Need <code>Clone</code> on boxed observable</td><td><code>box_it_clone()</code> / <code>box_it_mut_ref_clone()</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async-interoperability"><a class="header" href="#async-interoperability">Async Interoperability</a></h1>
<p>rxRust is designed to play nicely with Rust’s async ecosystem (Tokio, async-std, etc.). It fills the gap for complex event orchestration, allowing you to use ReactiveX patterns where standard <code>Future</code>s and <code>Stream</code>s might become cumbersome.</p>
<h2 id="1-future-interoperability-from_future--into_future"><a class="header" href="#1-future-interoperability-from_future--into_future">1. Future Interoperability: <code>from_future</code> / <code>into_future</code></a></h2>
<h3 id="from_future-converting-a-future-to-an-observable"><a class="header" href="#from_future-converting-a-future-to-an-observable"><code>from_future</code>: Converting a <code>Future</code> to an <code>Observable</code></a></h3>
<p>You can easily turn any <code>Future</code> into an <code>Observable</code> using the <code>from_future</code> operator. This is useful when you have an asynchronous operation that produces a single value (or an error) and you want to integrate it into an Rx pipeline, leveraging operators like <code>timeout</code>, <code>retry</code>, or <code>switch_map</code>.</p>
<p>The <code>from_future</code> operator takes ownership of the <code>Future</code> and emits its <code>Output</code> value as <code>next</code> when the <code>Future</code> completes.</p>
<pre class="playground"><code class="language-rust">use rxrust::prelude::*;
use tokio::time::sleep;

async fn delayed_greeting(name: &amp;str) -&gt; String {
    sleep(Duration::from_secs(1)).await;
    format!("Hello, {}!", name)
}

#[tokio::main]
async fn main() {
    println!("Starting Future to Observable example...");

    // Create a Future
    let my_future = delayed_greeting("Alice");

    // Convert the Future into an Observable
    Shared::from_future(my_future)
        .subscribe(|msg| {
            println!("Observable received: {}", msg);
        });

    // The main function needs to complete for the async task to run.
    // In a real application, you might have a long-running executor.
    sleep(Duration::from_secs(2)).await;
    println!("Future to Observable example finished.");
}</code></pre>
<h3 id="into_future-converting-an-observable-to-a-future"><a class="header" href="#into_future-converting-an-observable-to-a-future"><code>into_future</code>: Converting an <code>Observable</code> to a <code>Future</code></a></h3>
<p>Conversely, if you have an <code>Observable</code> that you expect to emit a single value (e.g., from a network request that completes once, or after applying <code>first()</code> or <code>take(1)</code>), you can convert it into a <code>Future</code> using <code>into_future</code>.</p>
<p>This is particularly useful for integrating the final result of an Rx pipeline back into an <code>async/.await</code> control flow.</p>
<pre class="playground"><code class="language-rust">use rxrust::prelude::*;

#[tokio::main]
async fn main() {
    println!("Starting Observable to Future example...");

    // Create an Observable that emits a few values and then completes
    let observable = Shared::from_iter(vec![10, 20, 30])
        .filter(|&amp;v| v &gt; 25) // Only 30 passes
        .take(1); // Take only the first matching value

    // Convert the Observable into a Future
    let result_future = observable.into_future();

    // Await the result
    match result_future.await {
        Ok(Ok(value)) =&gt; println!("Future resolved with: {}", value),
        Ok(Err(err)) =&gt; println!("Future resolved with an observable error: {:?}", err),
        Err(IntoFutureError::Empty) =&gt; {
            println!("Future resolved with no value (observable was empty).")
        }
        Err(IntoFutureError::MultipleValues) =&gt; {
            println!("Future resolved with multiple values (expected exactly one).")
        }
    }

    // Another example: an observable that completes without emitting
    let empty_observable = Shared::from_iter(std::iter::empty::&lt;i32&gt;());
    let empty_result = empty_observable.into_future().await;
    assert!(matches!(empty_result, Err(IntoFutureError::Empty)));
}</code></pre>
<h2 id="2-stream-interoperability-from_stream--into_stream"><a class="header" href="#2-stream-interoperability-from_stream--into_stream">2. Stream Interoperability: <code>from_stream</code> / <code>into_stream</code></a></h2>
<h3 id="from_stream-converting-a-stream-to-an-observable"><a class="header" href="#from_stream-converting-a-stream-to-an-observable"><code>from_stream</code>: Converting a <code>Stream</code> to an <code>Observable</code></a></h3>
<p>Rust’s standard <code>Stream</code> trait is a pull-based asynchronous iterator. <code>from_stream</code> allows you to take an existing <code>Stream</code> (e.g., from <code>tokio::io::split</code>, <code>tokio::sync::mpsc</code>, or <code>futures::stream</code>) and convert it into an <code>Observable</code>. This enables you to apply rxRust’s powerful set of operators, especially those focused on time-based logic, error handling, or complex event patterns.</p>
<pre class="playground"><code class="language-rust no_run">use rxrust::prelude::*;
use futures::stream::{self, StreamExt};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("Starting Stream to Observable example...");

    // Create a simple async Stream
    let my_stream = stream::iter(vec![1, 2, 3, 4, 5])
        .then(|v| async move {
            sleep(Duration::from_millis(500)).await; // Simulate async delay
            v * 10
        });

    // Convert the Stream into an Observable
    Shared::from_stream(my_stream)
        .filter(|&amp;v| v &gt; 20) // RxRust operator
        .map(|v| format!("Item: {}", v))
        .subscribe(|msg| {
            println!("Observable from Stream received: {}", msg);
        });

    sleep(Duration::from_secs(3)).await;
    println!("Stream to Observable example finished.");
}</code></pre>
<h3 id="into_stream-converting-an-observable-to-a-stream"><a class="header" href="#into_stream-converting-an-observable-to-a-stream"><code>into_stream</code>: Converting an <code>Observable</code> to a <code>Stream</code></a></h3>
<p>For situations where you have an <code>Observable</code> pipeline and you want to consume its emissions using standard <code>async/.await</code> syntax or integrate it into a part of your application that expects a <code>Stream</code>, <code>into_stream</code> is your go-to.</p>
<p>The resulting <code>Stream</code> yields <code>Result&lt;T, E&gt;</code> items, and ends (<code>None</code>) when the <code>Observable</code> completes (or after emitting an error).</p>
<pre class="playground"><code class="language-rust no_run">use rxrust::prelude::*;
use futures::StreamExt; // For .next() and .collect()

#[tokio::main]
async fn main() {
    println!("Starting Observable to Stream example...");

    // Create an Observable
    let observable = Shared::interval(Duration::from_millis(100))
        .take(3) // Emit 0, 1, 2 then complete
        .map(|v| v + 100);

    // Convert the Observable into a Stream
    let mut my_stream = observable.into_stream();

    // Consume the Stream using async/.await
    while let Some(item) = my_stream.next().await {
        match item {
            Ok(value) =&gt; println!("Stream received: {}", value),
            Err(err) =&gt; println!("Stream error: {:?}", err),
        }
    }
    println!("Observable to Stream example finished.");

    // You can also collect all items (if the stream is finite)
    let observable_to_collect = Shared::from_iter(vec![1, 2, 3]);
    let collected_items: Vec&lt;_&gt; = observable_to_collect.into_stream().collect().await;
    println!("Collected items: {:?}", collected_items);
}</code></pre>
<h2 id="3-tokio-integration-practice-scheduling-tasks"><a class="header" href="#3-tokio-integration-practice-scheduling-tasks">3. Tokio Integration Practice: Scheduling Tasks</a></h2>
<p>Ultimately, <code>rxRust</code>’s <code>Scheduler</code> implementations are designed to hand off tasks to the underlying asynchronous runtime (like Tokio) for execution.</p>
<p>By default, when using <code>SharedScheduler</code> in a native environment, rxRust is designed to integrate seamlessly with the Tokio runtime, leveraging <code>tokio::spawn</code> for task scheduling. This means if you have Tokio set up, <code>SharedScheduler</code> will automatically use it.</p>
<p>However, rxRust’s <code>Scheduler</code> is a trait. If your project uses a different asynchronous runtime (e.g., <code>async-std</code>) or a custom event loop, you can implement your own <code>Scheduler</code> trait to integrate rxRust with your specific runtime. This allows you to tailor how tasks are executed and scheduled to your environment. For more details on implementing custom schedulers, refer to <a href="../advanced/custom_context.html">Advanced Topics: Custom Context</a>.</p>
<p>When working with <code>tokio</code> (or other async runtimes), <code>observe_on</code> and <code>subscribe_on</code> operators combined with <code>SharedScheduler</code> allow you to precisely control where tasks are executed.</p>
<h3 id="observe_on-with-tokio"><a class="header" href="#observe_on-with-tokio"><code>observe_on</code> with Tokio</a></h3>
<p><code>observe_on</code> can be used to ensure that all downstream operations (including the final subscriber) execute on a specific scheduler. If you’re in a <code>tokio</code> context, <code>SharedScheduler</code> will typically leverage <code>tokio::spawn</code> to offload tasks.</p>
<pre class="playground"><code class="language-rust no_run">use rxrust::prelude::*;
use std::thread;

#[tokio::main]
async fn main() {
    println!("Starting Tokio observe_on example...");

    // Create an interval observable
    let source = Shared::interval(Duration::from_millis(100))
        .take(3); // Emit 0, 1, 2

    source
        .map(|v| {
            // This map might run on the creating thread or where the subscription is
            println!("Map on {:?}", thread::current().id());
            v * 2
        })
        .observe_on(SharedScheduler) // All emissions after this point will be processed via SharedScheduler
        .subscribe(|v| {
            // This subscriber will run on a Tokio worker thread
            println!("Subscriber on {:?}: Value = {}", thread::current().id(), v);
        });

    tokio::time::sleep(Duration::from_secs(1)).await; // Give time for operations to complete
    println!("Tokio observe_on example finished.");
}</code></pre>
<h3 id="subscribe_on-with-tokio"><a class="header" href="#subscribe_on-with-tokio"><code>subscribe_on</code> with Tokio</a></h3>
<p><code>subscribe_on</code> dictates where the <em>entire</em> observable chain, including the source observable’s setup and initial emissions, will be executed. This is useful for moving long-running or blocking source operations to a background thread from the start.</p>
<pre class="playground"><code class="language-rust no_run">use rxrust::prelude::*;
use std::thread;

#[tokio::main]
async fn main() {
    println!("Starting Tokio subscribe_on example...");

    // Create a simple observable
    let source = Shared::from_iter(0..3)
        .map(|v| {
            // This map will also be scheduled by subscribe_on's scheduler
            println!("Source Map on {:?}", thread::current().id());
            v * 10
        });

    source
        .subscribe_on(SharedScheduler) // The entire chain, including source setup, runs on SharedScheduler
        .subscribe(|v| {
            println!("Subscriber on {:?}: Value = {}", thread::current().id(), v);
        });

    tokio::time::sleep(Duration::from_millis(100)).await; // Give time for operations to complete
    println!("Tokio subscribe_on example finished.");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<p>Real-world patterns and recipes for rxRust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gui-development"><a class="header" href="#gui-development">GUI Development</a></h1>
<p>Integrating rxRust with GUI frameworks like Ribir.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm-development"><a class="header" href="#wasm-development">WASM Development</a></h1>
<p>Using rxRust in the browser.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-auto-save"><a class="header" href="#pattern-auto-save">Pattern: Auto-Save</a></h1>
<p>Implement auto-save functionality using <code>debounce</code> and <code>switch_map</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-heartbeat"><a class="header" href="#pattern-heartbeat">Pattern: Heartbeat</a></h1>
<p>Implement a heartbeat mechanism using <code>interval</code> and <code>take_until</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-state-store"><a class="header" href="#pattern-state-store">Pattern: State Store</a></h1>
<p>Implement a simple Redux-like state store using <code>BehaviorSubject</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>rxRust provides a comprehensive set of operators to transform, filter, and combine streams. These operators are the building blocks of reactive programming, allowing you to compose complex asynchronous logic in a declarative and readable way.</p>
<h2 id="learning-operators-marble-diagrams"><a class="header" href="#learning-operators-marble-diagrams">Learning Operators: Marble Diagrams</a></h2>
<p>To understand how each operator works, we highly recommend consulting the <a href="http://reactivex.io/documentation/operators.html">ReactiveX.io</a> documentation. It provides interactive “Marble Diagrams” which are visual representations of how an Observable (represented by a stream of marbles) is transformed by an operator over time. rxRust operators generally follow the same behavior as their ReactiveX counterparts.</p>
<p>For exact Rust function signatures and implementation details, please refer to the <strong><a href="https://docs.rs/rxrust">API Documentation</a></strong>.</p>
<h2 id="rust-specific-considerations"><a class="header" href="#rust-specific-considerations">Rust-Specific Considerations</a></h2>
<p>While the behavior of operators is largely consistent with ReactiveX, their usage in Rust comes with unique considerations due to Rust’s ownership and borrowing rules, as well as its type system. When using operators, pay close attention to:</p>
<ul>
<li><strong>Ownership and Moves</strong>: Many closures passed to operators will move captured variables. If you need to use a variable across multiple closures or after the Observable chain, you might need to <code>clone()</code> it or use <code>Arc</code>/<code>Rc</code> for shared ownership.</li>
<li><strong>Borrowing</strong>: Ensure that data borrowed by closures lives long enough. The compiler will guide you on this.</li>
<li><strong><code>Clone</code> Trait</strong>: For operators that might re-emit values (e.g., multicast or buffer operations), the item type <code>T</code> often needs to implement <code>Clone</code>.</li>
<li><strong>Context Compatibility</strong>: Remember that <code>Local</code> context streams are optimized for single-threaded usage (using <code>Rc</code>), while <code>Shared</code> context streams require types to be <code>Send + Sync</code> (using <code>Arc</code>) to safely work in multi-threaded environments.</li>
</ul>
<h2 id="operator-reference"><a class="header" href="#operator-reference">Operator Reference</a></h2>
<h3 id="creation-operators"><a class="header" href="#creation-operators">Creation Operators</a></h3>
<p>Operators that originate new Observables. These are typically factory methods available on <code>Local</code>, <code>Shared</code>, or your custom <code>Context</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>of</code></td><td style="text-align: left">Emits a single value and then completes.</td></tr>
<tr><td style="text-align: left"><code>from_iter</code></td><td style="text-align: left">Converts an <code>IntoIterator</code> (e.g., <code>Vec</code>, <code>Range</code>) into an Observable.</td></tr>
<tr><td style="text-align: left"><code>from_future</code></td><td style="text-align: left">Converts a <code>Future</code> into an Observable that emits its result. Variants exist for <code>_with</code> custom schedulers and <code>_result</code> for <code>Future&lt;Output=Result&lt;T,E&gt;&gt;</code>.</td></tr>
<tr><td style="text-align: left"><code>from_stream</code></td><td style="text-align: left">Converts an async <code>Stream</code> into an Observable. Variants exist for <code>_with</code> custom schedulers and <code>_result</code> for <code>Stream&lt;Item=Result&lt;T,E&gt;&gt;</code>.</td></tr>
<tr><td style="text-align: left"><code>from_fn</code></td><td style="text-align: left">Creates an Observable that emits a single value generated by a function at subscription time.</td></tr>
<tr><td style="text-align: left"><code>interval</code></td><td style="text-align: left">Emits sequential numbers at regular time intervals. Use <code>interval_with</code> for custom schedulers.</td></tr>
<tr><td style="text-align: left"><code>timer</code></td><td style="text-align: left">Emits a single item after a specified delay. Variants exist for <code>_with</code> custom schedulers and <code>_at</code> a specific instant.</td></tr>
<tr><td style="text-align: left"><code>defer</code></td><td style="text-align: left">Creates an Observable that calls a factory function to generate a new Observable for each subscriber.</td></tr>
<tr><td style="text-align: left"><code>create</code></td><td style="text-align: left">Creates an Observable from scratch by providing a function that defines the subscription logic with an <code>Emitter</code>.</td></tr>
<tr><td style="text-align: left"><code>empty</code></td><td style="text-align: left">Emits no items and immediately completes.</td></tr>
<tr><td style="text-align: left"><code>never</code></td><td style="text-align: left">Emits no items and never completes.</td></tr>
<tr><td style="text-align: left"><code>throw_err</code></td><td style="text-align: left">Emits no items and immediately errors.</td></tr>
<tr><td style="text-align: left"><code>subject</code></td><td style="text-align: left">Creates a new <code>Subject</code> (multicasting source, hot observable). Use <code>subject_mut_ref</code> for mutable reference broadcasting.</td></tr>
<tr><td style="text-align: left"><code>behavior_subject</code></td><td style="text-align: left">Creates a new <code>BehaviorSubject</code> (multicasting, replays last value). Use <code>behavior_subject_mut_ref</code> for mutable reference broadcasting.</td></tr>
<tr><td style="text-align: left"><code>merge_observables</code></td><td style="text-align: left">Merges multiple observables concurrently, subscribing to all at once.</td></tr>
<tr><td style="text-align: left"><code>concat_observables</code></td><td style="text-align: left">Concatenates multiple observables sequentially, subscribing one at a time.</td></tr>
</tbody>
</table>
</div>
<h3 id="transformation-operators"><a class="header" href="#transformation-operators">Transformation Operators</a></h3>
<p>Operators that transform the items emitted by an Observable.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>map</code></td><td style="text-align: left">Applies a function to each item emitted.</td></tr>
<tr><td style="text-align: left"><code>map_to</code></td><td style="text-align: left">Maps every emission to a constant value.</td></tr>
<tr><td style="text-align: left"><code>filter_map</code></td><td style="text-align: left">Maps and filters items in one step (using <code>Option</code>).</td></tr>
<tr><td style="text-align: left"><code>scan</code></td><td style="text-align: left">Applies an accumulator function to each item, emitting each intermediate result.</td></tr>
<tr><td style="text-align: left"><code>reduce</code></td><td style="text-align: left">Applies an accumulator function and emits only the final result.</td></tr>
<tr><td style="text-align: left"><code>flat_map</code></td><td style="text-align: left">Projects each item to an Observable, then merges them all.</td></tr>
<tr><td style="text-align: left"><code>concat_map</code></td><td style="text-align: left">Projects each item to an Observable, then concatenates them (preserving order).</td></tr>
<tr><td style="text-align: left"><code>buffer</code></td><td style="text-align: left">Collects items into a <code>Vec</code> until a notifier emits.</td></tr>
<tr><td style="text-align: left"><code>buffer_count</code></td><td style="text-align: left">Collects items into a <code>Vec</code> of a specific size.</td></tr>
<tr><td style="text-align: left"><code>buffer_time</code></td><td style="text-align: left">Collects items into a <code>Vec</code> for a specific duration.</td></tr>
<tr><td style="text-align: left"><code>pairwise</code></td><td style="text-align: left">Groups consecutive emissions into pairs <code>(prev, current)</code>.</td></tr>
<tr><td style="text-align: left"><code>group_by</code></td><td style="text-align: left">Divides an Observable into a set of Observables that each emit a different group of items.</td></tr>
</tbody>
</table>
</div>
<h3 id="filtering-operators"><a class="header" href="#filtering-operators">Filtering Operators</a></h3>
<p>Operators that selectively emit items from the source Observable.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>filter</code></td><td style="text-align: left">Emits only items that satisfy a predicate.</td></tr>
<tr><td style="text-align: left"><code>take</code></td><td style="text-align: left">Emits only the first <code>n</code> items.</td></tr>
<tr><td style="text-align: left"><code>take_last</code></td><td style="text-align: left">Emits only the last <code>n</code> items.</td></tr>
<tr><td style="text-align: left"><code>take_while</code></td><td style="text-align: left">Emits items as long as a predicate is true.</td></tr>
<tr><td style="text-align: left"><code>take_until</code></td><td style="text-align: left">Emits items until another Observable emits.</td></tr>
<tr><td style="text-align: left"><code>skip</code></td><td style="text-align: left">Skips the first <code>n</code> items.</td></tr>
<tr><td style="text-align: left"><code>skip_last</code></td><td style="text-align: left">Skips the last <code>n</code> items.</td></tr>
<tr><td style="text-align: left"><code>skip_while</code></td><td style="text-align: left">Skips items as long as a predicate is true.</td></tr>
<tr><td style="text-align: left"><code>skip_until</code></td><td style="text-align: left">Skips items until another Observable emits.</td></tr>
<tr><td style="text-align: left"><code>distinct</code></td><td style="text-align: left">Suppresses duplicate items.</td></tr>
<tr><td style="text-align: left"><code>distinct_until_changed</code></td><td style="text-align: left">Suppresses consecutive duplicate items.</td></tr>
<tr><td style="text-align: left"><code>debounce</code></td><td style="text-align: left">Emits an item only after a specific timespan has passed without another emission.</td></tr>
<tr><td style="text-align: left"><code>throttle</code></td><td style="text-align: left">Emits the first item emitted during a time window.</td></tr>
<tr><td style="text-align: left"><code>sample</code></td><td style="text-align: left">Emits the most recent item when another Observable emits.</td></tr>
<tr><td style="text-align: left"><code>last</code></td><td style="text-align: left">Emits only the last item.</td></tr>
<tr><td style="text-align: left"><code>contains</code></td><td style="text-align: left">Emits true if the Observable emits a specific item.</td></tr>
</tbody>
</table>
</div>
<h3 id="combination-operators"><a class="header" href="#combination-operators">Combination Operators</a></h3>
<p>Operators that work with multiple source Observables to create a single Observable.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>merge</code></td><td style="text-align: left">Interleaves items from multiple Observables.</td></tr>
<tr><td style="text-align: left"><code>zip</code></td><td style="text-align: left">Combines items from multiple Observables pairwise.</td></tr>
<tr><td style="text-align: left"><code>combine_latest</code></td><td style="text-align: left">Combines the latest item from each Observable whenever any emits.</td></tr>
<tr><td style="text-align: left"><code>with_latest_from</code></td><td style="text-align: left">Merges the current item with the latest item from another Observable.</td></tr>
<tr><td style="text-align: left"><code>start_with</code></td><td style="text-align: left">Emits a sequence of items before beginning to emit the items from the source.</td></tr>
<tr><td style="text-align: left"><code>merge_all</code></td><td style="text-align: left">Flattens a Higher-Order Observable by merging inner Observables.</td></tr>
<tr><td style="text-align: left"><code>concat_all</code></td><td style="text-align: left">Flattens a Higher-Order Observable by concatenating inner Observables sequentially.</td></tr>
</tbody>
</table>
</div>
<h3 id="utility-operators"><a class="header" href="#utility-operators">Utility Operators</a></h3>
<p>Operators for observing, timing, and error handling.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>tap</code></td><td style="text-align: left">Performs a side effect for every emission (next, error, complete).</td></tr>
<tr><td style="text-align: left"><code>delay</code></td><td style="text-align: left">Shifts the emissions forward in time by a specified delay.</td></tr>
<tr><td style="text-align: left"><code>delay_subscription</code></td><td style="text-align: left">Delays the moment of subscription.</td></tr>
<tr><td style="text-align: left"><code>observe_on</code></td><td style="text-align: left">Specifies the Scheduler on which an observer will observe this Observable.</td></tr>
<tr><td style="text-align: left"><code>subscribe_on</code></td><td style="text-align: left">Specifies the Scheduler on which the subscription will happen.</td></tr>
<tr><td style="text-align: left"><code>finalize</code></td><td style="text-align: left">Registers a callback to be called when the Observable terminates.</td></tr>
<tr><td style="text-align: left"><code>retry</code></td><td style="text-align: left">Resubscribes to the source Observable if it signals an error.</td></tr>
<tr><td style="text-align: left"><code>map_err</code></td><td style="text-align: left">Transforms the error type.</td></tr>
<tr><td style="text-align: left"><code>on_error</code></td><td style="text-align: left">Performs a side effect if an error occurs.</td></tr>
<tr><td style="text-align: left"><code>on_complete</code></td><td style="text-align: left">Performs a side effect if the Observable completes.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>Deep dives into extending rxRust and understanding its architecture.</p>
<p>rxRust v1.0 is built on a <strong>Unified Architecture</strong> where the <code>Context</code> drives everything. This design allows operators to be implemented once (“Environment-Agnostic”) and automatically adapt to single-threaded (<code>Local</code>) or multi-threaded (<code>Shared</code>) environments.</p>
<p>This section is for library authors, framework integrators, and users who need to customize rxRust’s execution model.</p>
<h2 id="core-concepts-for-extensions"><a class="header" href="#core-concepts-for-extensions">Core Concepts for Extensions</a></h2>
<p>To effectively extend rxRust, it helps to understand the three pillars of its architecture:</p>
<ol>
<li>
<p><strong>Context (<code>Context</code> Trait)</strong>:
The container that defines the <em>execution environment</em>. It carries the <strong>Scheduler</strong> (e.g., <code>LocalScheduler</code>, <code>TokioScheduler</code>) and the <strong>Inner Logic</strong> (the operator chain). It handles the “how” and “where” of execution.</p>
</li>
<li>
<p><strong>Logic Kernel (<code>CoreObservable</code> Trait)</strong>:
The pure logic of an operator (e.g., <code>Map</code>, <code>Filter</code>). It is generic over the <code>Context</code>, allowing it to be “injected” into any environment.</p>
</li>
<li>
<p><strong>Type Propagation (<code>ObservableType</code> Trait)</strong>:
A dedicated trait that exposes the <code>Item</code> and <code>Err</code> types, ensuring that type inference works cleanly across the complex generic boundaries of the Context.</p>
</li>
</ol>
<h2 id="in-this-section"><a class="header" href="#in-this-section">In This Section</a></h2>
<h3 id="architecture-deep-dive"><a class="header" href="#architecture-deep-dive"><a href="advanced/architecture_deep_dive.html">Architecture Deep Dive</a></a></h3>
<p>Understand the foundational traits (<code>Context</code>, <code>CoreObservable</code>, <code>ObservableType</code>) that make rxRust’s unified architecture possible.</p>
<ul>
<li><strong>Context as Environment</strong>: Explore how the <code>Context</code> trait carries the scheduler and manages ownership strategy.</li>
<li><strong>Type Propagation</strong>: Learn about <code>Self::With&lt;T&gt;</code> and how it ensures type safety and environment-agnostic operator chaining.</li>
</ul>
<h3 id="custom-operators"><a class="header" href="#custom-operators"><a href="#custom-operators-1">Custom Operators</a></a></h3>
<p>Learn how to implement first-class operators that feel native to rxRust.</p>
<ul>
<li><strong>Write Once, Run Everywhere</strong>: Create operators that work in both <code>Local</code> and <code>Shared</code> contexts without code duplication.</li>
<li><strong>The <code>CoreObservable</code> Pattern</strong>: See how to implement the glue logic that connects your operator to the Context.</li>
<li><strong>Performance</strong>: How rxRust’s zero-cost abstractions ensure your custom operators compile down to optimized code.</li>
</ul>
<h3 id="nightly-experimental"><a class="header" href="#nightly-experimental"><a href="#nightly-experimental-1">Nightly (Experimental)</a></a></h3>
<p>Notes on nightly-only experiments (currently: lifetime-dependent mapped outputs in <code>map</code>).</p>
<h3 id="custom-schedulers--runtimes"><a class="header" href="#custom-schedulers--runtimes"><a href="#custom-scheduler--runtimes">Custom Schedulers &amp; Runtimes</a></a></h3>
<p>Learn how to take control of time and execution.</p>
<ul>
<li><strong>Game Loops</strong>: Synchronize <code>interval</code>, <code>timer</code>, and <code>delay</code> operators with your game’s tick loop.</li>
<li><strong>GUI Integration</strong>: Integrate rxRust with GTK, Qt, or web-based event loops.</li>
<li><strong>Virtual Time Testing</strong>: Use deterministic schedulers to test time-dependent logic reliably.</li>
<li><strong>The Type Alias Pattern</strong>: How to inject your custom scheduler into <code>Local</code> or <code>Shared</code> contexts with zero runtime overhead.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-scheduler--runtimes"><a class="header" href="#custom-scheduler--runtimes">Custom Scheduler &amp; Runtimes</a></h1>
<p>While rxRust provides robust default environments through <code>Local</code> (single-threaded) and <code>Shared</code> (multi-threaded) contexts, one of its most powerful features is the ability to adapt to specialized execution environments.</p>
<p>This guide explains how to inject custom schedulers into rxRust. This is the primary way to integrate rxRust with:</p>
<ul>
<li><strong>Game Loops</strong>: Synchronize time-based operators (<code>delay</code>, <code>interval</code>) with game ticks.</li>
<li><strong>GUI Event Loops</strong>: Integrate with frameworks like GTK, Qt, or platform-specific loops.</li>
<li><strong>Test Environments</strong>: Use virtual time for deterministic testing.</li>
<li><strong>Embedded Systems</strong>: Run on bare-metal or RTOS environments.</li>
</ul>
<h2 id="the-context-vs-scheduler-distinction"><a class="header" href="#the-context-vs-scheduler-distinction">The “Context” vs. “Scheduler” Distinction</a></h2>
<p>A common misconception is that you need to implement a new <code>Context</code> to change how tasks are executed. <strong>This is almost never necessary.</strong></p>
<ul>
<li><strong>Context (<code>Context</code> Trait)</strong>: A complex container that manages <strong>State</strong> (the inner value), <strong>Ownership Strategy</strong> (Rc vs Arc), and <strong>Type Propagation</strong> (<code>With&lt;T&gt;</code>). Implementing this from scratch is difficult and involves complex Generic Associated Types (GATs).</li>
<li><strong>Scheduler (<code>Scheduler</code> Trait)</strong>: The component responsible for <em>scheduling work</em> and <em>tracking time</em>. This is what you usually want to customize.</li>
</ul>
<p><strong>The Recommended Pattern</strong>: Use the existing <code>LocalCtx</code> or <code>SharedCtx</code> containers and simply <strong>plug in</strong> your custom Scheduler via a type alias.</p>
<h2 id="the-type-alias-pattern-zero-cost-injection"><a class="header" href="#the-type-alias-pattern-zero-cost-injection">The Type Alias Pattern (Zero-Cost Injection)</a></h2>
<p>rxRust is designed to allow compile-time injection of schedulers using Rust’s type system. This incurs <strong>zero runtime overhead</strong> (no dynamic dispatch/vtable lookups for the scheduler itself).</p>
<h3 id="step-1-implement-your-scheduler"><a class="header" href="#step-1-implement-your-scheduler">Step 1: Implement Your Scheduler</a></h3>
<p>First, define your scheduler struct. You need to implement two traits:</p>
<ol>
<li><code>SleepProvider</code>: Tells rxRust how to handle time (sleep/yield) in your environment. This automatically makes rxRust’s internal tasks compatible with your scheduler.</li>
<li><code>Scheduler</code>: The main interface for scheduling tasks.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: Your scheduler usually needs to implement <code>Default</code> to work seamlessly with the <code>ObservableFactory</code> methods (like <code>MyContext::of(...)</code>).</p>
</blockquote>
<pre><code class="language-rust ignore">use rxrust::prelude::*;
use rxrust::scheduler::{Scheduler, Schedulable, TaskHandle, SleepProvider};
use std::time::Duration;

#[derive(Clone, Default)]
pub struct MyGameScheduler;

// 1. Implement SleepProvider
//    This allows rxRust's internal Task&lt;S&gt; to automatically run on your scheduler.
impl SleepProvider for MyGameScheduler {
    // The future type returned by sleep(). 
    // In a game engine, this might be a handle to a timer system.
    type SleepFuture = std::future::Ready&lt;()&gt;; 

    fn sleep(&amp;self, _duration: Duration) -&gt; Self::SleepFuture {
        // Implementation that waits for 'duration'
        std::future::ready(())
    }
}

// 2. Implement the Scheduler logic
//    We implement it for ANY Schedulable item (S), which covers both
//    rxRust Tasks (via SleepProvider) and native Futures.
impl&lt;S&gt; Scheduler&lt;S&gt; for MyGameScheduler
where
    S: Schedulable&lt;MyGameScheduler&gt; + 'static,
{
    fn schedule(&amp;self, source: S, delay: Option&lt;Duration&gt;) -&gt; TaskHandle {
        // Convert the source into a Future
        let future = source.into_future(self);
        
        // Push the future to your game loop's executor
        // global_game_loop::spawn(future);
        
        TaskHandle::finished() // Return a handle to allow cancellation
    }
}</code></pre>
<h3 id="step-2-define-the-context-alias"><a class="header" href="#step-2-define-the-context-alias">Step 2: Define the Context Alias</a></h3>
<p>Now, create a type alias that binds <code>LocalCtx</code> (for single-threaded) or <code>SharedCtx</code> (for multi-threaded) to your new scheduler.</p>
<pre><code class="language-rust ignore">use rxrust::context::LocalCtx;

// This is your new "Context". Use it just like `Local`.
pub type GameRx&lt;T&gt; = LocalCtx&lt;T, MyGameScheduler&gt;;</code></pre>
<h3 id="step-3-use-it"><a class="header" href="#step-3-use-it">Step 3: Use It!</a></h3>
<p>You can now use <code>GameRx</code> as the entry point for your reactive streams. All operators created from this chain will automatically use <code>MyGameScheduler</code> for time-based operations.</p>
<pre><code class="language-rust ignore">fn main() {
    // This looks exactly like standard rxRust code!
    GameRx::of(42)
        .delay(Duration::from_millis(100)) // Uses MyGameScheduler logic!
        .map(|v| v * 2)
        .subscribe(|v| println!("Value: {}", v));
}</code></pre>
<h2 id="why-this-works-context-as-an-environment-carrier"><a class="header" href="#why-this-works-context-as-an-environment-carrier">Why This Works: Context as an Environment Carrier</a></h2>
<p>Under the hood, rxRust’s <code>Context</code> acts as a dependency injection system.</p>
<p>When you call <code>GameRx::of(42)</code>, you are utilizing the <code>ObservableFactory</code> trait (which <code>LocalCtx</code> implements) to create a struct:</p>
<pre><code class="language-rust ignore">LocalCtx {
    inner: Of(42),
    scheduler: MyGameScheduler::default(), // Automatically injected here
}</code></pre>
<p>When you apply an operator like <code>.map(...)</code>, the <code>Context</code> trait’s <code>With&lt;T&gt;</code> associated type ensures the scheduler type is preserved:</p>
<pre><code class="language-rust ignore">// Simplified view of what .map() does
fn map(self, f) -&gt; LocalCtx&lt;Map&lt;...&gt;, MyGameScheduler&gt; {
    LocalCtx {
        inner: Map::new(self.inner, f),
        scheduler: self.scheduler, // Passes the SAME scheduler instance down
    }
}</code></pre>
<p>This guarantees that a <code>delay</code> operator ten steps down the chain still has access to the correct <code>MyGameScheduler</code> without you ever passing it explicitly.</p>
<h2 id="when-to-implement-context-manually"><a class="header" href="#when-to-implement-context-manually">When to Implement <code>Context</code> Manually?</a></h2>
<p>Implementing the full <code>Context</code> trait is an advanced task reserved for scenarios where <code>LocalCtx</code> (Rc/RefCell) or <code>SharedCtx</code> (Arc/Mutex) are fundamentally incompatible with your requirements.</p>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>Bare-metal Embedded</strong>: If you have no heap (<code>alloc</code>) and cannot use <code>Rc</code> or <code>Arc</code>.</li>
<li><strong>Specialized GC</strong>: If you are integrating with a garbage-collected runtime (like a JS engine host) and need to use <code>Gc&lt;T&gt;</code> instead of standard reference counting.</li>
</ul>
<p>If you find yourself in this situation, refer to <code>src/context.rs</code> and the <code>impl_context_for_container!</code> macro for the reference implementation. You will need to define:</p>
<ol>
<li><strong>Storage Strategy</strong>: How inner values are stored (<code>Rc</code>, <code>Arc</code>, or custom).</li>
<li><strong>Mutability Strategy</strong>: How mutation is handled (<code>RefCell</code>, <code>Mutex</code>, or custom cells).</li>
</ol>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>For a fully runnable example that implements a logging scheduler and executes tasks, check out:
<code>examples/custom_scheduler.rs</code></p>
<p>You can run it with:</p>
<pre><code class="language-bash">cargo run --example custom_scheduler
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-operators-1"><a class="header" href="#custom-operators-1">Custom Operators</a></h1>
<p>In rxRust v1.0, the best way to implement a custom operator is to build it as an <strong>Environment-Agnostic Operator</strong> starting from the <code>CoreObservable</code> trait.</p>
<p>Instead of hacking together <code>Local</code> or <code>Shared</code> specific implementations, rxRust allows you to write the logic <strong>once</strong> and have it automatically adapt to any environment (Single-threaded, Multi-threaded, WASM, etc.).</p>
<h2 id="the-architecture"><a class="header" href="#the-architecture">The Architecture</a></h2>
<p>To create a custom operator, you typically need four core components:</p>
<ol>
<li><strong>The Operator Struct</strong>: Holds the source observable and any parameters (e.g., <code>Map { source, func }</code>)</li>
<li><strong>The Observer Struct</strong>: Wraps the downstream observer to intercept and transform events (e.g., <code>MapObserver { observer, func }</code>)</li>
<li><strong><code>CoreObservable</code> Implementation</strong>: The “glue” logic that connects the operator to the source, generic over the <code>Context</code></li>
<li><strong>Integration</strong>: How you expose the operator (either as an extension trait for external use or directly in the Observable trait for contributions)</li>
</ol>
<h2 id="walkthrough-implementing-maptostring"><a class="header" href="#walkthrough-implementing-maptostring">Walkthrough: Implementing <code>MapToString</code></a></h2>
<p>Let’s implement a <code>MapToString</code> operator that calls <code>.to_string()</code> on every emitted item.</p>
<h3 id="step-1-the-operator-struct"><a class="header" href="#step-1-the-operator-struct">Step 1: The Operator Struct</a></h3>
<p>First, define a struct to represent your operator. It needs to hold the source observable.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;
use rxrust::observable::{CoreObservable, ObservableType};
use rxrust::observer::Observer;
use rxrust::context::Context;

pub struct MapToString&lt;S&gt; {
    pub source: S,
}
<span class="boring">}</span></code></pre>
<h3 id="step-2-the-observer-logic"><a class="header" href="#step-2-the-observer-logic">Step 2: The Observer Logic</a></h3>
<p>Define an Observer wrapper that intercepts the <code>next</code> event. This is where your operator’s business logic lives.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::observer::Observer;

pub struct MapToStringObserver&lt;O&gt; {
    observer: O,
}

impl&lt;O, Item, Err&gt; Observer&lt;Item, Err&gt; for MapToStringObserver&lt;O&gt;
where
    O: Observer&lt;String, Err&gt;, // Downstream expects String
    Item: std::fmt::Display,  // Upstream provides Display-able items
{
    fn next(&amp;mut self, v: Item) {
        // LOGIC HERE: Transform item to String
        let s = v.to_string();
        // Pass to downstream
        self.observer.next(s);
    }

    fn error(self, e: Err) {
        self.observer.error(e);
    }

    fn complete(self) {
        self.observer.complete();
    }

    fn is_closed(&amp;self) -&gt; bool {
        self.observer.is_closed()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="step-3-observabletype"><a class="header" href="#step-3-observabletype">Step 3: <code>ObservableType</code></a></h3>
<p>Tell rxRust what kind of items your operator produces.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rxrust::prelude::*;

pub struct MapToString&lt;S&gt; {
    pub source: S,
}

impl&lt;S&gt; ObservableType for MapToString&lt;S&gt;
where
    S: ObservableType,
{
    // Our operator always produces Strings
    type Item&lt;'a&gt; = String where Self: 'a;
    type Err = S::Err;
}
<span class="boring">}</span></code></pre>
<h3 id="step-4-coreobservable-the-glue"><a class="header" href="#step-4-coreobservable-the-glue">Step 4: <code>CoreObservable</code> (The Glue)</a></h3>
<p>This is the most critical part. We implement <code>CoreObservable&lt;C&gt;</code> where <code>C</code> is a generic <strong>Context</strong>.</p>
<p>This implementation says: “If the Source <code>S</code> can accept a Context wrapping our <code>MapToStringObserver</code>, then <code>MapToString</code> is a valid observable.”</p>
<pre><code class="language-rust ignore">impl&lt;S, C&gt; CoreObservable&lt;C&gt; for MapToString&lt;S&gt;
where
    C: Context,
    // Constraint: The source must be able to work with our wrapped observer
    S: CoreObservable&lt;C::With&lt;MapToStringObserver&lt;C::Inner&gt;&gt;&gt;,
    // Constraint: The source items must be Display-able
    for&lt;'a&gt; S::Item&lt;'a&gt;: std::fmt::Display,
{
    type Unsub = S::Unsub;

    fn subscribe(self, context: C) -&gt; Self::Unsub {
        // The context.transform method is the key.
        // It unwraps the downstream observer (context.inner),
        // lets you wrap it in your own observer (MapToStringObserver),
        // and repacks it into the same type of Context (Local/Shared).
        let wrapped_context = context.transform(|observer| MapToStringObserver { observer });

        // Subscribe the source to our wrapped context
        self.source.subscribe(wrapped_context)
    }
}</code></pre>
<h3 id="step-5-integration"><a class="header" href="#step-5-integration">Step 5: Integration</a></h3>
<p>This is where the path splits depending on your use case:</p>
<h4 id="51-external-operators-for-your-project"><a class="header" href="#51-external-operators-for-your-project">5.1 External Operators (For Your Project)</a></h4>
<p>If you’re implementing this operator for use in your own project, create an extension trait:</p>
<pre><code class="language-rust ignore">pub trait MapToStringOp: Observable {
    fn map_to_string(self) -&gt; Self::With&lt;MapToString&lt;Self::Inner&gt;&gt;
    where
        for&lt;'a&gt; Self::Item&lt;'a&gt;: std::fmt::Display,
    {
        // self.transform is a helper on the Observable trait
        // that handles the Context wrapping/unwrapping for the operator struct itself.
        self.transform(|source| MapToString { source })
    }
}

// Blanket implementation for all Observables
impl&lt;T: Observable&gt; MapToStringOp for T {}</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-rust ignore">use rxrust::prelude::*;

fn main() {
    // Works in Local Context
    Local::of(123)
        .map_to_string()
        .subscribe(|s| println!("Local String: {}", s));

    // Works in Shared Context
    Shared::of(456)
        .map_to_string()
        .subscribe(|s| println!("Shared String: {}", s));
}</code></pre>
<h4 id="52-contributing-operators-to-rxrust"><a class="header" href="#52-contributing-operators-to-rxrust">5.2 Contributing Operators to rxRust</a></h4>
<p>If you’re contributing this operator to the rxRust library itself, integrate directly:</p>
<ol>
<li>
<p><strong>Create your operator file</strong> in the appropriate location:</p>
<ul>
<li>All operators are located in <code>src/ops/</code> as individual files</li>
<li>No subdirectories - flat organization</li>
<li>Example: <code>src/ops/map_to_string.rs</code></li>
</ul>
</li>
<li>
<p><strong>Add the method to the main <code>Observable</code> trait</strong> in <code>src/observable.rs</code>:</p>
</li>
</ol>
<pre><code class="language-rust ignore">// In src/observable.rs
pub trait Observable: Sized {
    // ... existing methods

    fn map_to_string(self) -&gt; Self::With&lt;ops::MapToString&lt;Self::Inner&gt;&gt;
    where
        for&lt;'a&gt; Self::Item&lt;'a&gt;: std::fmt::Display,
    {
        self.transform(|source| ops::MapToString { source })
    }
}</code></pre>
<ol start="3">
<li><strong>Ensure proper re-exports</strong> in <code>src/ops/mod.rs</code> and <code>src/lib.rs</code></li>
</ol>
<p><strong>Requirements for Contributing:</strong></p>
<ol>
<li>
<p><strong>Documentation</strong>: Include comprehensive rustdoc comments explaining:</p>
<ul>
<li>What the operator does</li>
<li>Parameter descriptions</li>
<li>Example usage</li>
<li>Performance considerations</li>
</ul>
</li>
<li>
<p><strong>Tests</strong>: Add comprehensive tests covering:</p>
<ul>
<li>Basic functionality</li>
<li>Edge cases</li>
<li>Error handling</li>
<li>Both <code>Local</code> and <code>Shared</code> contexts</li>
</ul>
</li>
<li>
<p><strong>Location</strong>: All operators go in <code>src/ops/</code> as individual files (flat organization). Examples of existing files:</p>
<ul>
<li><code>map.rs</code>, <code>filter.rs</code>: For operators that transform/filter items</li>
<li><code>zip.rs</code>, <code>merge.rs</code>: For operators that combine multiple observables</li>
<li><code>retry.rs</code>, <code>map_err.rs</code>: For error handling operators</li>
<li><code>scan.rs</code>, <code>reduce.rs</code>: For aggregation operators</li>
<li><code>debounce.rs</code>, <code>throttle.rs</code>: For time-based operators</li>
</ul>
</li>
</ol>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>By starting from <code>CoreObservable&lt;C&gt;</code>, you ensure your operator:</p>
<ol>
<li><strong>Environment Agnostic</strong>: Works for <code>Local</code> (WASM/UI) and <code>Shared</code> (Tokio/Thread) automatically</li>
<li><strong>Type Safe</strong>: Leveraging Rust’s trait system to propagate types</li>
<li><strong>Performant</strong>: Zero-cost abstractions; the compiler optimizes the wrapper structs away</li>
</ol>
<p>The first 4 steps are identical for both external operators and contributions. Only step 5 (integration) differs based on where the operator will live.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nightly-experimental-1"><a class="header" href="#nightly-experimental-1">Nightly (Experimental)</a></h1>
<p>rxRust targets <strong>stable Rust</strong> by default.</p>
<p>This page documents a small set of <strong>nightly-only experimental capabilities</strong>
used to explore advanced type-system use cases.</p>
<h2 id="lifetime-dependent-mapped-outputs-why-stable-map-is-limited"><a class="header" href="#lifetime-dependent-mapped-outputs-why-stable-map-is-limited">Lifetime-dependent mapped outputs (why stable <code>map</code> is limited)</a></h2>
<p>rxRust’s <code>ObservableType</code> uses a GAT (<code>type Item&lt;'a&gt;</code>) so an observable can emit
values that <em>borrow</em> from a scope in a controlled way (this is essential for
patterns like <code>subject_mut_ref</code> / <code>multicast_mut_ref</code>).</p>
<p>However, on <strong>stable Rust</strong> there is an important limitation when defining
operators like <code>map</code>:</p>
<ul>
<li>The stable-friendly signature is typically written as
<code>F: for&lt;'a&gt; FnMut(S::Item&lt;'a&gt;) -&gt; Out</code>.</li>
<li>This makes <code>Out</code> a <em>single fixed type</em>, which means the mapped output type
cannot depend on the input lifetime <code>'a</code>.</li>
</ul>
<p>So mappings that conceptually look like <code>&amp;'a T -&gt; &amp;'a U</code> (or <code>&amp;'a mut T -&gt; &amp;'a U</code>)
cannot be expressed through the stable <code>map</code> API, because it would require a
type family <code>Out&lt;'a&gt;</code>.</p>
<h2 id="experimental-support-in-map-nightly-only"><a class="header" href="#experimental-support-in-map-nightly-only">Experimental support in <code>map</code> (nightly only)</a></h2>
<p>rxRust provides an <strong>experimental</strong> implementation of <code>map</code> behind a Cargo
feature flag:</p>
<ul>
<li>Feature: <code>nightly</code></li>
<li>Requires a nightly compiler</li>
</ul>
<p>Enable it like this:</p>
<pre><code class="language-toml">[dependencies]
rxrust = { version = "1.0.0-rc.0", features = ["nightly"] }
</code></pre>
<p>And build/tests with nightly:</p>
<pre><code class="language-bash">cargo +nightly test --features nightly
</code></pre>
<p>With the nightly feature enabled, <code>map</code> can be used in patterns where the output
borrows from the input (example uses <code>subject_mut_ref</code>):</p>
<pre><code class="language-rust ignore">use rxrust::prelude::*;
use std::convert::Infallible;

fn as_ref&lt;'a&gt;(v: &amp;'a mut i32) -&gt; &amp;'a i32 { v }

let subject = Local::subject_mut_ref::&lt;i32, Infallible&gt;();
subject.map(as_ref).subscribe(|v: &amp;i32| {
    // v is tied to the emission's lifetime
    assert!(*v &gt;= 0 || *v &lt; 0);
});</code></pre>
<h2 id="why-we-dont-roll-this-out-to-every-operator"><a class="header" href="#why-we-dont-roll-this-out-to-every-operator">Why we don’t roll this out to every operator</a></h2>
<p>We intentionally keep this behavior <strong>limited to <code>map</code></strong> for now:</p>
<ul>
<li>It relies on nightly-only features and subtle type inference behavior.</li>
<li>Duplicating this across many operators increases maintenance cost
significantly.</li>
<li>When the relevant capabilities become stable, we can support lifetime-dependent
output types across more operators with a single, maintainable design.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing-to-rxrust"><a class="header" href="#contributing-to-rxrust">Contributing to rxRust</a></h1>
<p>We welcome and appreciate all contributions to rxRust! Whether it’s reporting bugs, suggesting new features, improving documentation, or submitting code, your help makes this project better.</p>
<h2 id="roadmap--missing-features"><a class="header" href="#roadmap--missing-features">Roadmap &amp; Missing Features</a></h2>
<p>We maintain a list of features and operators that are either planned or would be valuable additions to rxRust. Please refer to <code>missing_features.md</code> in the project root for the current roadmap and a list of operators that need implementation. If you’re looking for a good place to start, picking an operator from this list is an excellent way to contribute!</p>
<p>For guidance on how to implement custom operators to contribute to rxRust, please see <a href="#52-contributing-operators-to-rxrust">Step 5.2: Contributing Operators to rxRust</a> in the Custom Operators guide.</p>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<ol>
<li>
<p><strong>Fork and Clone</strong>: Start by forking the <code>rxRust</code> repository on GitHub and cloning your fork locally.</p>
<pre><code class="language-bash">git clone https://github.com/your-username/rxRust.git
cd rxRust
</code></pre>
</li>
<li>
<p><strong>Create a Branch</strong>: Create a new branch for your feature or bug fix.</p>
<pre><code class="language-bash">git checkout -b feature/my-new-operator
# or
git checkout -b bugfix/fix-issue-123
</code></pre>
</li>
<li>
<p><strong>Code Style</strong>: rxRust enforces consistent code style and formatting.</p>
<ul>
<li><strong>Formatting</strong>: We use <code>rustfmt</code>. Before committing, run:
<pre><code class="language-bash">cargo +nightly fmt
</code></pre>
</li>
<li><strong>Linting</strong>: We use <code>clippy</code> for linting. Always run <code>clippy</code> to catch common mistakes and improve your code.
<pre><code class="language-bash">cargo clippy --all-targets --all-features
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Testing</strong>:</p>
<ul>
<li><strong>Unit Tests</strong>: Run all unit tests to ensure your changes haven’t introduced regressions:
<pre><code class="language-bash">cargo test --all-targets --all-features
</code></pre>
</li>
<li><strong>Examples</strong>: If you’re adding a significant new feature or a complex operator, or if existing examples don’t cover your changes well, please include an example in the <code>examples/</code> directory or update relevant examples in the <code>guide/</code> to demonstrate its usage. We welcome examples, but there’s no need to create a dedicated example for every single operator.</li>
<li><strong>Documentation Examples</strong>: Ensure any code examples in the documentation (<code>guide/</code>) compile and work correctly.</li>
</ul>
</li>
</ol>
<h2 id="submitting-a-pull-request-pr"><a class="header" href="#submitting-a-pull-request-pr">Submitting a Pull Request (PR)</a></h2>
<p>Once you’re satisfied with your changes and all tests pass:</p>
<ol>
<li>
<p><strong>Commit Your Changes</strong>: Write clear, concise commit messages.</p>
<pre><code class="language-bash">git add .
git commit -m "feat: implement my new amazing operator"
</code></pre>
</li>
<li>
<p><strong>Push to Your Fork</strong>:</p>
<pre><code class="language-bash">git push origin feature/my-new-operator
</code></pre>
</li>
<li>
<p><strong>Open a Pull Request</strong>: Go to the original <code>rxRust</code> repository on GitHub and open a new Pull Request from your forked branch to the <code>main</code> branch.</p>
<ul>
<li><strong>Describe Your Changes</strong>: Provide a clear description of your changes, including:
<ul>
<li>What problem does this PR solve?</li>
<li>How does it solve it?</li>
<li>Any relevant context, design decisions, or trade-offs.</li>
<li>Link to any open issues this PR addresses (e.g., “Closes #123”).</li>
</ul>
</li>
<li><strong>Code Review</strong>: Be prepared for feedback and discussions during the code review process. We might suggest changes to improve readability, performance, or adherence to project conventions.</li>
</ul>
</li>
</ol>
<p>Thank you for contributing to rxRust! Your efforts help us build a more robust and complete reactive programming library for Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/version-picker-782f5426.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
